<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>MARS MISSION CONTROL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=JetBrains+Mono:wght@300;500&display=swap");

      :root {
        --mars-red: #ff3e3e;
        --mars-gold: #fbbf24;
        --comms-green: #00ff41;
        --bg-dark: #0a0a0c;
        --panel-bg: rgba(16, 16, 20, 0.8);
      }

      body {
        background-color: var(--bg-dark);
        color: var(--comms-green);
        font-family: "JetBrains Mono", monospace;
        background-image: linear-gradient(
            rgba(0, 255, 65, 0.03) 1px,
            transparent 1px
          ),
          linear-gradient(90deg, rgba(0, 255, 65, 0.03) 1px, transparent 1px);
        background-size: 30px 30px;
      }

      .header-font {
        font-family: "Orbitron", sans-serif;
      }

      .glass-panel {
        background: var(--panel-bg);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 255, 65, 0.2);
        box-shadow: inset 0 0 15px rgba(0, 255, 65, 0.05);
      }

      #imu-canvas-container {
        width: 100%;
        height: 300px;
        cursor: move;
      }

      .critical-glow {
        animation: pulse-red 1.5s infinite;
        border-color: var(--mars-red) !important;
      }

      @keyframes pulse-red {
        0% {
          box-shadow: 0 0 5px var(--mars-red);
        }
        50% {
          box-shadow: 0 0 20px var(--mars-red);
        }
        100% {
          box-shadow: 0 0 5px var(--mars-red);
        }
      }

      .scanline {
        width: 100%;
        height: 2px;
        background: rgba(0, 255, 65, 0.1);
        position: absolute;
        animation: scan 4s linear infinite;
      }

      @keyframes scan {
        from {
          top: 0;
        }
        to {
          top: 100%;
        }
      }
    </style>
  </head>
  <body class="min-h-screen p-4 lg:p-8 overflow-x-hidden">
    <div class="scanline"></div>

    <header
      class="flex flex-col md:flex-row justify-between items-start md:items-center mb-8 border-b border-green-900 pb-6"
    >
      <div>
        <h1 class="header-font text-3xl font-black tracking-[0.2em] text-white">
          MARS<span class="text-green-500">_UPLINK</span
          ><span class="text-xs align-top ml-2 opacity-50"></span>
        </h1>
        <div class="flex items-center gap-4 mt-2">
          <div class="flex items-center gap-2">
            <div
              id="status-dot"
              class="w-2 h-2 rounded-full bg-yellow-500 animate-pulse"
            ></div>
            <span
              id="status"
              class="text-xs font-bold text-yellow-500 tracking-tighter uppercase"
              >Initializing Link...</span
            >
          </div>
          <span class="text-[10px] opacity-40"
            ></span
          >
        </div>
      </div>

      <div
        id="alarm-banner"
        class="hidden mt-4 md:mt-0 glass-panel border-red-600 bg-red-950/30 px-6 py-3 flex items-center gap-4"
      >
        <span class="flex h-3 w-3 relative">
          <span
            class="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"
          ></span>
          <span
            class="relative inline-flex rounded-full h-3 w-3 bg-red-500"
          ></span>
        </span>
        <span class="header-font text-red-500 font-bold tracking-widest text-sm"
          >CRITICAL: DUST STORM DETECTED</span
        >
      </div>
    </header>

    <main class="grid grid-cols-12 gap-4 h-[calc(100vh-160px)]">
      <div class="col-span-12 lg:col-span-9 flex flex-col gap-4">
        <div class="glass-panel p-4 rounded-sm flex-1 relative min-h-[300px]">
          <h3
            class="header-font text-[10px] font-bold text-green-400 tracking-widest mb-2 border-b border-green-900/30 pb-1"
          >
            CUBESAT_ORIENTATION (3D_IMU)
          </h3>
          <div id="imu-canvas-container" class="h-[calc(100%-40px)]"></div>
          <div
            class="absolute bottom-4 right-4 flex gap-6 text-[10px] opacity-70 bg-black/40 p-2 rounded"
          >
            <div>PITCH: <span id="val-pitch" class="text-white">0</span>°</div>
            <div>ROLL: <span id="val-roll" class="text-white">0</span>°</div>
            <div>YAW: <span id="val-yaw" class="text-white">0</span>°</div>
          </div>
        </div>

        <div class="grid grid-cols-2 gap-4 h-[220px]">
          <div class="glass-panel p-4 rounded-sm relative overflow-hidden">
            <div class="flex justify-between items-center mb-2">
              <h3
                class="header-font text-[10px] font-bold text-red-400 tracking-wider uppercase"
              >
                Atmospheric Temp (°C)
              </h3>
              <span id="val-temp" class="text-xl font-bold text-white font-mono"
                >--.-</span
              >
            </div>
            <div class="h-[150px]">
              <canvas id="tempChart"></canvas>
            </div>
          </div>

          <div class="glass-panel p-4 rounded-sm relative overflow-hidden">
            <div class="flex justify-between items-center mb-2">
              <h3
                class="header-font text-[10px] font-bold text-yellow-400 tracking-wider uppercase"
              >
                Solar Lux (Lux)
              </h3>
              <span id="val-ldr" class="text-xl font-bold text-white font-mono"
                >----</span
              >
            </div>
            <div class="h-[150px]">
              <canvas id="lightChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <div class="col-span-12 lg:col-span-3 flex flex-col gap-4">
        <div
          id="vibe-card"
          class="glass-panel p-6 rounded-sm transition-all flex flex-col justify-center border-l-4 border-l-green-500"
        >
          <div class="text-[9px] opacity-50 uppercase tracking-widest mb-1">
            Seismic Activity
          </div>
          <div id="vibe-val" class="header-font text-2xl font-bold">STABLE</div>
          <div
            class="w-full bg-green-950 h-1 mt-3 rounded-full overflow-hidden"
          >
            <div
              class="bg-green-500 h-full w-1/4 shadow-[0_0_10px_#00ff41]"
            ></div>
          </div>
        </div>

        <div
          id="ir-card"
          class="glass-panel p-6 rounded-sm transition-all flex flex-col justify-center border-l-4 border-l-blue-500"
        >
          <div class="text-[9px] opacity-50 uppercase tracking-widest mb-1">
            Atmo. Clarity
          </div>
          <div id="ir-val" class="header-font text-2xl font-bold">CLEAR</div>
        </div>

        <div
          class="glass-panel flex-1 rounded-sm border-t-2 border-t-green-900/50 flex flex-col"
        >
          <div
            class="header-font text-[9px] font-bold p-3 border-b border-green-900/30 opacity-80"
          >
            >> CUBESAT_BEACON_LOG
          </div>
          <div
            id="beacon-log"
            class="text-[10px] p-3 leading-relaxed opacity-60 italic overflow-y-auto font-mono flex-1 h-0"
          >
            WAITING FOR DATA PACKETS...
          </div>
        </div>
      </div>
    </main>

    <script>
      // Chart Styling Helper

      // --- THREE.JS ORIENTATION LOGIC ---
      // --- THREE.JS UPDATED FOR 3D MODEL ---
      const container = document.getElementById("imu-canvas-container");
      const scene = new THREE.Scene();
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      // Lighting (Boosted for a complex model)
      const light = new THREE.DirectionalLight(0xffffff, 1.5);
      light.position.set(1, 1, 1).normalize();
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040, 2));

      const perspectiveCamera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      perspectiveCamera.position.set(4, 4, 4);
      perspectiveCamera.lookAt(0, 0, 0);

      let roverModel; // This replaces 'cube'

      // Load your converted GLB file
      const loader = new THREE.GLTFLoader();
 loader.load(
  "cubsat.glb",
  (gltf) => {
    roverModel = gltf.scene;

    // 1. Calculate the current bounding box
    const box = new THREE.Box3().setFromObject(roverModel);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());

    // 2. Shift the model's internal geometry so it pivots around the center
    // We subtract the center coordinates from the model's position
    roverModel.position.x = -center.x;
    roverModel.position.y = -center.y;
    roverModel.position.z = -center.z;

    // 3. Create a "Pivot Group" to hold the shifted model
    // This group becomes the new reference point for rotations
    const pivotGroup = new THREE.Group();
    scene.add(pivotGroup);
    pivotGroup.add(roverModel);

    // 4. Important: Re-assign roverModel to the group 
    // This ensures your MQTT rotation logic rotates the center-point
    roverModel = pivotGroup;

    // 5. Auto-Scale: Adjust the number (e.g., 3.0) to fill the panel better
    const maxDim = Math.max(size.x, size.y, size.z);
    const scaleFactor = 3 / maxDim; 
    roverModel.scale.set(scaleFactor, scaleFactor, scaleFactor);

    console.log("Model successfully centered on pivot point.");
  },
  undefined,
  (error) => console.error("Load Error:", error)
);

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, perspectiveCamera);
      }
      animate();

      const createChartConfig = (label, color, minY, maxY) => ({
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: label,
              borderColor: color,
              backgroundColor: color + "11",
              data: [],
              borderWidth: 2,
              pointBackgroundColor: color,
              pointRadius: 0,
              pointHoverRadius: 5,
              fill: true,
              tension: 0.4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { display: false },
            y: {
              min: minY,
              max: maxY,
              grid: { color: "rgba(0, 255, 65, 0.05)" },
              ticks: { color: "rgba(255,255,255,0.3)", font: { size: 10 } },
            },
          },
          plugins: { legend: { display: false } },
        },
      });

      const tempChart = new Chart(
        document.getElementById("tempChart"),
        createChartConfig("Temp", "#ff3e3e", -20, 50)
      );
      const lightChart = new Chart(
        document.getElementById("lightChart"),
        createChartConfig("Light", "#fbbf24", 0, 1024)
      );

      function updateDashboardCharts(temp, light) {
        const now = new Date().toLocaleTimeString();
        const maxPoints = 20;

        [
          { chart: tempChart, val: temp },
          { chart: lightChart, val: light },
        ].forEach(({ chart, val }) => {
          chart.data.labels.push(now);
          chart.data.datasets[0].data.push(val);
          if (chart.data.labels.length > maxPoints) {
            chart.data.labels.shift();
            chart.data.datasets[0].data.shift();
          }
          chart.update("none");
        });
      }

      // MQTT Connection
      const client = new Paho.MQTT.Client(
        "192.168.0.34",
        9001,
        "mars_dash_" + Math.random()
      );

      let stormTimeout = null;
      let tremorTimeout = null;

      client.onMessageArrived = (message) => {
        try {
          const data = JSON.parse(message.payloadString);

          // Update 3D Rotation (Convert degrees to radians)
          // Note: MPU6050 axes might need swapping depending on mounting
          if (data.pitch !== undefined && roverModel) {
            const p = THREE.MathUtils.degToRad(data.pitch);
            const r = THREE.MathUtils.degToRad(data.roll);
            const y = THREE.MathUtils.degToRad(data.yaw);

            roverModel.rotation.set(p, y, r); // Order depends on rover orientation

            document.getElementById("val-pitch").innerText = Math.round(
              data.pitch
            );
            document.getElementById("val-roll").innerText = Math.round(
              data.roll
            );
            document.getElementById("val-yaw").innerText = Math.round(data.yaw);
          }

          if (data.temp !== undefined && data.light !== undefined) {
            updateDashboardCharts(data.temp, data.light);
            document.getElementById("val-temp").innerText =
              data.temp.toFixed(1) + "°";
            document.getElementById("val-ldr").innerText = data.light;
          }

          const vibeVal = document.getElementById("vibe-val");
          const vibeCard = document.getElementById("vibe-card");
          // Vibration logic
          if (data.vibe > 0) {
            clearTimeout(tremorTimeout); // Reset timer if a new tremor hits
            vibeVal.innerText = "TREMOR!";
            vibeVal.className =
              "header-font text-3xl font-bold text-red-500 animate-pulse";
            vibeCard.classList.add("critical-glow");

            // Hold the "TREMOR" state for 3 seconds
            tremorTimeout = setTimeout(() => {
              vibeVal.innerText = "STABLE";
              vibeVal.className =
                "header-font text-3xl font-bold text-green-500";
              vibeCard.classList.remove("critical-glow");
            }, 3000);
          }

          // IR/Storm logic
          const irCard = document.getElementById("ir-card");
          const irVal = document.getElementById("ir-val");
          const alarmBanner = document.getElementById("alarm-banner");
          if (data.ir_storm === true) {
            clearTimeout(stormTimeout);
            document.getElementById("ir-val").innerText = "STORM";
            document.getElementById("ir-val").classList.add("text-red-500");
            document.getElementById("ir-card").classList.add("critical-glow");
            document.getElementById("alarm-banner").classList.remove("hidden");
            document.getElementById(
              "beacon-log"
            ).innerHTML += `<div>[${new Date().toLocaleTimeString()}] WARNING: DUST_STORM_EVENT</div>`;
            stormTimeout = setTimeout(() => {
              document.getElementById("ir-val").innerText = "CLEAR";
              document
                .getElementById("ir-val")
                .classList.remove("text-red-500");
              document
                .getElementById("ir-card")
                .classList.remove("critical-glow");
              document.getElementById("alarm-banner").classList.add("hidden");
            }, 5000);
          }
        } catch (e) {
          console.error("Update Error:", e);
        }
      };

      client.connect({
        onSuccess: () => {
          document.getElementById("status").innerText = "UPLINK_ESTABLISHED";
          document
            .getElementById("status-dot")
            .classList.replace("bg-yellow-500", "bg-green-500");
          document
            .getElementById("status")
            .classList.replace("text-yellow-500", "text-green-500");
          client.subscribe("mars/telemetry");
        },
        onFailure: (err) => {
          document.getElementById("status").innerText = "CONNECTION_FAILED";
          document
            .getElementById("status-dot")
            .classList.replace("bg-yellow-500", "bg-red-500");
        },
      });

      // Resize 3D canvas on window change
      window.addEventListener("resize", () => {
        perspectiveCamera.aspect =
          container.clientWidth / container.clientHeight;
        perspectiveCamera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    </script>
  </body>
</html>
